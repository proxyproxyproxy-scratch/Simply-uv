<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Three.js FPS with joystick & jump</title>
<style>
  body { margin:0; overflow:hidden; }
  canvas { display:block; }
  #joystick {
    position: fixed;
    bottom: 20px;
    left: 20px;
    width: 200px;
    height: 200px;
    border-radius: 50%;
    background-color: #ffffffcc;
    touch-action: none;
  }
  #jumpBtn {
    position: fixed;
    bottom: 50px;
    right: 20px;
    width: 80px;
    height: 80px;
    border-radius: 50%;
    background-color: #ffffffcc;
    font-size: 20px;
    text-align: center;
    line-height: 80px;
    user-select: none;
    touch-action: none;
  }
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="joystick"></div>
<div id="jumpBtn">Jump</div>

<script src="https://unpkg.com/three@0.137.4/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.137.4/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.9.0/nipplejs.min.js"></script>

<script>
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 5, 500);
camera.position.set(0,50,25);

const renderer = new THREE.WebGLRenderer({canvas:document.getElementById('canvas')});
renderer.setSize(window.innerWidth, window.innerHeight);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableZoom = false;
controls.enablePan = false;
controls.target.set(0,50,0);
controls.update();

scene.add(new THREE.AmbientLight(0xffffff,0.6));
const dirLight = new THREE.DirectionalLight(0xffffff,0.6);
dirLight.position.set(100,200,100);
scene.add(dirLight);

const blockSize = 25;
const texture = new THREE.TextureLoader().load("images/soil.png");
texture.magFilter = THREE.NearestFilter;
texture.minFilter = THREE.NearestMipMapNearestFilter;

// --- ブロックデータ保存用 ---
const Cubes = {}; // { "x,z": [ {x,y,z,type}, ... ] }

function createBlock(x,y,z,type="soil"){
  const geometry = new THREE.BoxGeometry(blockSize,blockSize,blockSize);

  // UV設定
  const tileUvWidth = 1/4, tileUvHeight=1/3;
  function applyFaceUV(faceIndex, tx, ty){
    const uvs = geometry.attributes.uv.array;
    const offset = faceIndex*4*2;
    const u0=tx*tileUvWidth,v0=1-(ty+1)*tileUvHeight;
    const u1=(tx+1)*tileUvWidth,v1=1-ty*tileUvHeight;
    uvs[offset] = u0; uvs[offset+1]=v1;
    uvs[offset+2] = u1; uvs[offset+3]=v1;
    uvs[offset+4] = u0; uvs[offset+5]=v0;
    uvs[offset+6] = u1; uvs[offset+7] = v0;
  }
  applyFaceUV(0,2,1); applyFaceUV(1,0,1);
  applyFaceUV(2,1,0); applyFaceUV(3,1,2);
  applyFaceUV(4,1,1); applyFaceUV(5,3,1);
  geometry.attributes.uv.needsUpdate = true;

  const material = new THREE.MeshLambertMaterial({map:texture});
  const cube = new THREE.Mesh(geometry,material);
  cube.position.set(x,y+blockSize/2,z);
  scene.add(cube);

  // 保存
  const key = `${x},${z}`;
  if(!Cubes[key]) Cubes[key] = [];
  Cubes[key].push({
    x: x,
    y: y + blockSize/2, // 中心座標
    z: z,
    type: type
  });
}

// 地面生成
for(let i=-5;i<=5;i++){
  for(let j=-5;j<=5;j++){
    createBlock(i*blockSize,0,j*blockSize,"soil");
  }
}

// --- getGroundHeight 関数 ---
function getGroundHeight(x,y,z){
  const rx = Math.round(x/blockSize)*blockSize;
  const rz = Math.round(z/blockSize)*blockSize;
  const key = `${rx},${rz}`;
  if(!Cubes[key]) return 0; // 地面なし→0

  let ground = -Infinity;
  for(const block of Cubes[key]){
    const top = block.y + blockSize/2; // 上面
    if(top <= y && top > ground){
      ground = top;
    }
  }
  return ground === -Infinity ? 0 : ground;
}

// --- ジョイスティック ---
const joystick = nipplejs.create({
  zone: document.getElementById('joystick'),
  mode:'static',
  position:{left:'50%',top:'50%'},
  size:200,
  color:'blue',
  multitouch:true
});

let moveForward=0, moveRight=0;
joystick.on('move',(evt,data)=>{
  const rad = data.angle.radian;
  moveForward = Math.sin(rad) * data.distance * 0.02;
  moveRight   = Math.cos(rad) * data.distance * 0.02;
});
joystick.on('end',()=>{ moveForward=0; moveRight=0; });

// --- ジャンプ ---
let velocityY=0;
const gravity=-0.8, jumpSpeed=3.1;
let onGround=true;

const jumpBtn = document.getElementById('jumpBtn');
const jumpHandler = () => { if(onGround){ velocityY=jumpSpeed; onGround=false; } };
jumpBtn.addEventListener('touchstart', jumpHandler);
jumpBtn.addEventListener('pointerdown', jumpHandler);

window.addEventListener('keydown',(e)=>{
  if(e.code==='Space' && onGround){ velocityY=jumpSpeed; onGround=false; }
});

const forward = new THREE.Vector3();
const right = new THREE.Vector3();

function animate(){
  requestAnimationFrame(animate);

  camera.getWorldDirection(forward);
  forward.y = 0; forward.normalize();
  right.crossVectors(forward,new THREE.Vector3(0,1,0)).normalize();

  // 移動 (ここは元のまま)
  camera.position.addScaledVector(forward, moveForward);
  controls.target.addScaledVector(forward, moveForward);
  camera.position.addScaledVector(right, moveRight);
  controls.target.addScaledVector(right, moveRight);

  // ジャンプ / 重力
  const offsetY = camera.position.y - controls.target.y;
  velocityY += gravity * 0.1;
  camera.position.y += velocityY;
  controls.target.y += velocityY;

  // 着地判定
  const groundHeight = getGroundHeight(camera.position.x, controls.target.y, camera.position.z);
  if(controls.target.y <= groundHeight){
    if(groundHeight === 0){
      // --- リスポーン処理 ---
      camera.position.set(0,100,0);
      controls.target.set(0,100-offsetY,0);
      velocityY = 0;
      onGround = false;
    }else{
      // 通常着地
      controls.target.y = groundHeight;
      camera.position.y = groundHeight + offsetY;
      velocityY = 0;
      onGround = true;
    }
  }

  controls.update();
  renderer.render(scene,camera);
}
animate();

window.addEventListener('resize',()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>
</body>
</html>
