<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Three.js FPS with joystick & jump</title>
<style>
  body { margin:0; overflow:hidden; }
  canvas { display:block; }
  #joystick {
    position: fixed;
    bottom: 20px;
    left: 20px;
    width: 200px;
    height: 200px;
    border-radius: 50%;
    background-color: #ffffffcc;
    touch-action: none;
  }
  #jumpBtn {
    position: fixed;
    bottom: 50px;
    right: 20px;
    width: 80px;
    height: 80px;
    border-radius: 50%;
    background-color: #ffffffcc;
    font-size: 20px;
    text-align: center;
    line-height: 80px;
    user-select: none;
    touch-action: none;
  }
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="joystick"></div>
<div id="jumpBtn">Jump</div>

<script src="https://unpkg.com/three@0.137.4/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.137.4/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.9.0/nipplejs.min.js"></script>

<script>
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 5, 500);
camera.position.set(0, 50, 25);

const renderer = new THREE.WebGLRenderer({canvas: document.getElementById('canvas')});
renderer.setSize(window.innerWidth, window.innerHeight);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableZoom = false;
controls.enablePan = false;
controls.target.set(0, 50, 0);
controls.update();

scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
dirLight.position.set(100, 200, 100);
scene.add(dirLight);

const blockSize = 25;
const texture = new THREE.TextureLoader().load("images/dirt.png");
texture.magFilter = THREE.NearestFilter;
texture.minFilter = THREE.NearestMipMapNearestFilter;

const cubes = [];

function createBlock(x, y, z){
  const geometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
  const tileUvWidth = 1/4, tileUvHeight=1/3;
  function applyFaceUV(faceIndex, tx, ty){
    const uvs = geometry.attributes.uv.array;
    const offset = faceIndex*4*2;
    const u0=tx*tileUvWidth,v0=1-(ty+1)*tileUvHeight;
    const u1=(tx+1)*tileUvWidth,v1=1-ty*tileUvHeight;
    uvs[offset] = u0; uvs[offset+1]=v1;
    uvs[offset+2] = u1; uvs[offset+3]=v1;
    uvs[offset+4] = u0; uvs[offset+5]=v0;
    uvs[offset+6] = u1; uvs[offset+7] = v0;
  }
  applyFaceUV(0,2,1); applyFaceUV(1,0,1);
  applyFaceUV(2,1,0); applyFaceUV(3,1,2);
  applyFaceUV(4,1,1); applyFaceUV(5,3,1);
  geometry.attributes.uv.needsUpdate = true;
  const material = new THREE.MeshLambertMaterial({map:texture});
  const cube = new THREE.Mesh(geometry, material);
  cube.position.set(x, y + blockSize/2, z);
  scene.add(cube);
  cubes.push(cube);
}

// 地面
for(let i=-5; i<=5; i++){
  for(let j=-5; j<=5; j++){
    createBlock(i*blockSize, 0, j*blockSize);
  }
}

// ジョイスティック
const joystick = nipplejs.create({
  zone: document.getElementById('joystick'),
  mode:'static',
  position:{left:'50%', top:'50%'},
  size:200,
  color:'blue',
  multitouch:true
});

let moveForward = 0, moveRight = 0;
joystick.on('move', (evt,data)=>{
  const rad = data.angle.radian;
  moveForward = Math.sin(rad) * data.distance * 0.02;
  moveRight   = Math.cos(rad) * data.distance * 0.02;
});
joystick.on('end', ()=>{ moveForward=0; moveRight=0; });

// ジャンプ
let velocityY = 0;
const gravity = -0.8, jumpSpeed = 3.1;
let onGround = false;

const jumpBtn = document.getElementById('jumpBtn');
const jumpHandler = () => { if(onGround){ velocityY=jumpSpeed; onGround=false; } };
jumpBtn.addEventListener('touchstart', jumpHandler);
jumpBtn.addEventListener('pointerdown', jumpHandler);
window.addEventListener('keydown', (e)=>{ if(e.code==='Space' && onGround){ velocityY=jumpSpeed; onGround=false; } });

const forward = new THREE.Vector3();
const right = new THREE.Vector3();
const respawnHeight = -50;

function checkCollisionY(posY){
  let maxGroundY = -Infinity;
  for(const cube of cubes){
    const topY = cube.position.y + blockSize/2;
    const halfSize = blockSize/2;
    const dx = Math.abs(camera.position.x - cube.position.x);
    const dz = Math.abs(camera.position.z - cube.position.z);
    if(dx < halfSize && dz < halfSize && topY <= posY){
      if(topY > maxGroundY) maxGroundY = topY;
    }
  }
  return maxGroundY;
}

function animate(){
  requestAnimationFrame(animate);

  camera.getWorldDirection(forward);
  forward.y = 0; forward.normalize();
  right.crossVectors(forward, new THREE.Vector3(0,1,0)).normalize();

  // 移動
  camera.position.addScaledVector(forward, moveForward);
  camera.position.addScaledVector(right, moveRight);
  controls.target.addScaledVector(forward, moveForward);
  controls.target.addScaledVector(right, moveRight);

  // ジャンプ・重力
  velocityY += gravity*0.1;
  camera.position.y += velocityY;
  controls.target.y += velocityY;

  // 接地判定
  const groundY = checkCollisionY(camera.position.y - 1);
  if(camera.position.y <= groundY){
    camera.position.y = groundY;
    controls.target.y = groundY;
    velocityY = 0;
    onGround = true;
  }

  // 下限リスポーン
  if(camera.position.y < respawnHeight){
    camera.position.set(0, 50, 25);
    controls.target.set(0, 50, 0);
    velocityY = 0;
    onGround = false;
  }

  controls.update();
  renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', ()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
