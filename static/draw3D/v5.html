<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Three.js FPS with Blocks</title>
<style>
  body { margin:0; overflow:hidden; }
  canvas { display:block; }
  #joystick {
    position: fixed;
    bottom: 20px;
    left: 20px;
    width: 200px;
    height: 200px;
    border-radius: 50%;
    background-color: #ffffffcc;
    overflow: hidden;
  }
  #jumpBtn {
    position: fixed;
    bottom: 40px;
    right: 40px;
    width: 80px;
    height: 80px;
    border-radius: 50%;
    background: orange;
    color: white;
    font-size: 20px;
    border: none;
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
  }
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="joystick"></div>
<button id="jumpBtn">↑</button>

<script src="https://unpkg.com/three@0.137.4/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.137.4/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.9.0/nipplejs.min.js"></script>

<script>
  // ===== シーン =====
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb);

  // ===== カメラ =====
  const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 1000);
  camera.position.set(0, 50, 25);
  const playerHeight = 50;


  // ===== レンダラー =====
  const renderer = new THREE.WebGLRenderer({ canvas: document.querySelector('#canvas') });
  renderer.setSize(window.innerWidth, window.innerHeight);

  // ===== OrbitControls（見渡す専用） =====
  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableZoom = false;
  controls.enablePan = false;
  controls.target.set(0, 50, 0);
  controls.update();

  // ===== 光源 =====
  scene.add(new THREE.AmbientLight(0xffffff, 0.6));
  const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
  dirLight.position.set(100, 200, 100);
  scene.add(dirLight);

  // ===== ブロック =====
  const blockSize = 25;
  const blocks = []; // 当たり判定用配列

  const texture = new THREE.TextureLoader().load("images/dirt.png");
  texture.magFilter = THREE.NearestFilter;
  texture.minFilter = THREE.NearestMipMapNearestFilter;

  function createBlock(x, y, z){
    const geometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
    const tileUvWidth  = 1/4, tileUvHeight = 1/3;
    function applyFaceUV(faceIndex, tx, ty){
      const uvs = geometry.attributes.uv.array;
      const offset = faceIndex * 4 * 2;
      const u0 = tx * tileUvWidth, v0 = 1 - (ty+1) * tileUvHeight;
      const u1 = (tx+1) * tileUvWidth, v1 = 1 - ty * tileUvHeight;
      uvs[offset]   = u0; uvs[offset+1] = v1;
      uvs[offset+2] = u1; uvs[offset+3] = v1;
      uvs[offset+4] = u0; uvs[offset+5] = v0;
      uvs[offset+6] = u1; uvs[offset+7] = v0;
    }
    applyFaceUV(0,2,1); applyFaceUV(1,0,1);
    applyFaceUV(2,1,0); applyFaceUV(3,1,2);
    applyFaceUV(4,1,1); applyFaceUV(5,3,1);
    geometry.attributes.uv.needsUpdate = true;
    const material = new THREE.MeshLambertMaterial({map: texture});
    const cube = new THREE.Mesh(geometry, material);
    cube.position.set(x, y+blockSize/2, z);
    scene.add(cube);

    // 当たり判定用情報
    blocks.push({x:x, y:y, z:z, size:blockSize});
  }

  // ===== 地面 =====
  for(let i=-5;i<=5;i++){
    for(let j=-5;j<=5;j++){
      createBlock(i*blockSize, 0, j*blockSize);
    }
  }

  // ===== ジョイスティック =====
  const joystick = nipplejs.create({
    zone: document.getElementById('joystick'),
    mode: 'static',
    position: { left: '50%', top: '50%' },
    size: 200,
    color: 'blue'
  });

  let moveForward = 0;
  let moveRight   = 0;
  joystick.on('move', (evt, data)=>{
    const rad = data.angle.radian;
    moveForward = Math.sin(rad) * data.distance * 0.02;
    moveRight   = Math.cos(rad) * data.distance * 0.02;
  });
  joystick.on('end', ()=>{
    moveForward = 0;
    moveRight = 0;
  });

  // ===== ジャンプ =====
  let vy = 0;
  let isGrounded = true;
  const gravity = -0.5;
  const jumpPower = 12;

  document.getElementById("jumpBtn").addEventListener("click", ()=>{
    if(isGrounded){
      vy = jumpPower;
      isGrounded = false;
    }
  });

  // ===== 当たり判定関数 =====
  function checkGround(yFeet){
    // 足の高さがブロックの上面に触れていれば接地
    for(let b of blocks){
      const half = b.size / 2;
      if(
        camera.position.x >= b.x - half && camera.position.x <= b.x + half &&
        camera.position.z >= b.z - half && camera.position.z <= b.z + half
      ){
        if(yFeet <= b.y + b.size && yFeet >= b.y){
          return b.y + b.size; // 接地
        }
      }
    }
    return null; // 空中
  }

  // ===== アニメーション =====
  const forward = new THREE.Vector3();
  const right = new THREE.Vector3();

  function animate(){
    requestAnimationFrame(animate);

    // カメラ向き
    camera.getWorldDirection(forward);
    forward.y = 0;
    forward.normalize();
    right.crossVectors(forward, new THREE.Vector3(0,1,0)).normalize();

    // 移動
    camera.position.addScaledVector(forward, moveForward);
    controls.target.addScaledVector(forward, moveForward);
    camera.position.addScaledVector(right, moveRight);
    controls.target.addScaledVector(right, moveRight);

    // 足の高さ
    const yFeet = camera.position.y - playerHeight/2;

    // 重力
    vy += gravity;
    camera.position.y += vy;
    controls.target.y += vy;

    // 接地判定
    const groundY = checkGround(yFeet);
    if(groundY !== null){
      camera.position.y = groundY + playerHeight/2;
      controls.target.y = camera.position.y;
      vy = 0;
      isGrounded = true;
    } else {
      isGrounded = false;
    }

    controls.update();
    renderer.render(scene, camera);
  }
  animate();

  // ===== リサイズ =====
  window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>
