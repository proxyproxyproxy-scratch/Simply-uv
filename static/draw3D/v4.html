<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Three.js FPS style movement</title>
<style>
  body { margin:0; overflow:hidden; }
  canvas { display:block; }
  #joystick {
    position: fixed;
    bottom: 20px;
    left: 20px;
    width: 200px;
    height: 200px;
    border-radius: 50%;
    background-color: #ffffffcc;
  }
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="joystick"></div>

<!-- Three.js -->
<script src="https://unpkg.com/three@0.137.4/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.137.4/examples/js/controls/OrbitControls.js"></script>
<!-- NippleJS -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.9.0/nipplejs.min.js"></script>

<script>
  // ===== シーン =====
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb);

  // ===== カメラ =====
  const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 5, 500);
  camera.position.set(0, 50, 150);

  // ===== レンダラー =====
  const renderer = new THREE.WebGLRenderer({ canvas: document.querySelector('#canvas') });
  renderer.setSize(window.innerWidth, window.innerHeight);

  // ===== OrbitControls（見渡す専用） =====
  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableZoom = false;
  controls.enablePan = false;
  controls.target.set(0, 50, 25);
  controls.update();

  // ===== 光源 =====
  scene.add(new THREE.AmbientLight(0xffffff, 0.6));
  const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
  dirLight.position.set(100, 200, 100);
  scene.add(dirLight);

  // ===== ブロック関数 =====
  const blockSize = 25;
  const texture = new THREE.TextureLoader().load("images/dirt.png");
  texture.magFilter = THREE.NearestFilter;
  texture.minFilter = THREE.NearestMipMapNearestFilter;

  function createBlock(x, y, z){
    const geometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
    const tileUvWidth  = 1/4, tileUvHeight = 1/3;
    function applyFaceUV(faceIndex, tx, ty){
      const uvs = geometry.attributes.uv.array;
      const offset = faceIndex * 4 * 2;
      const u0 = tx * tileUvWidth, v0 = 1 - (ty+1) * tileUvHeight;
      const u1 = (tx+1) * tileUvWidth, v1 = 1 - ty * tileUvHeight;
      uvs[offset]   = u0; uvs[offset+1] = v1;
      uvs[offset+2] = u1; uvs[offset+3] = v1;
      uvs[offset+4] = u0; uvs[offset+5] = v0;
      uvs[offset+6] = u1; uvs[offset+7] = v0;
    }
    applyFaceUV(0,2,1); applyFaceUV(1,0,1);
    applyFaceUV(2,1,0); applyFaceUV(3,1,2);
    applyFaceUV(4,1,1); applyFaceUV(5,3,1);
    geometry.attributes.uv.needsUpdate = true;
    const material = new THREE.MeshLambertMaterial({map: texture});
    const cube = new THREE.Mesh(geometry, material);
    cube.position.set(x, y+blockSize/2, z);
    scene.add(cube);
  }

  // ===== 地面生成 =====
  for(let i=-5;i<=5;i++){
    for(let j=-5;j<=5;j++){
      createBlock(i*blockSize, 0, j*blockSize);
    }
  }

  // ===== ジョイスティック設定 =====
  const joystick = nipplejs.create({
    zone: document.getElementById('joystick'),
    mode: 'static',
    position: { left: '50%', top: '50%' },
    size: 100,
    color: 'blue'
  });

  let moveForward = 0;
  let moveRight = 0;

  joystick.on('move', (evt, data)=>{
    const rad = data.angle.radian;
    // 前進成分 (y軸回転に合わせて)
    moveForward = Math.sin(rad) * data.distance * 0.02;
    moveRight   = Math.cos(rad) * data.distance * 0.02;
  });

  joystick.on('end', ()=>{
    moveForward = 0;
    moveRight = 0;
  });

  // ===== アニメーション =====
  const forward = new THREE.Vector3();
  const right = new THREE.Vector3();

  function animate(){
    requestAnimationFrame(animate);

    // カメラの向きを基準に進行方向を決定
    camera.getWorldDirection(forward);   // カメラが向いている方向ベクトル
    forward.y = 0;                       // 上下成分は無視（水平移動）
    forward.normalize();

    right.crossVectors(forward, new THREE.Vector3(0,1,0)).normalize();

    // 移動を加算
    camera.position.addScaledVector(forward, moveForward);
    controls.target.addScaledVector(forward, moveForward);

    camera.position.addScaledVector(right, moveRight);
    controls.target.addScaledVector(right, moveRight);

    controls.update();
    renderer.render(scene, camera);
  }
  animate();

  // ===== リサイズ対応 =====
  window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>
