<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>FPSマイクラ風地面</title>
<style>
  body { margin:0; overflow:hidden; }
  canvas { display:block; }
</style>
</head>
<body>
<canvas id="canvas"></canvas>

<script src="https://unpkg.com/three@0.137.4/build/three.min.js"></script>
<script>
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 500);
const renderer = new THREE.WebGLRenderer({canvas: document.querySelector('#canvas')});
renderer.setSize(window.innerWidth, window.innerHeight);

scene.add(new THREE.AmbientLight(0xffffff,0.6));
const dirLight = new THREE.DirectionalLight(0xffffff,0.6);
dirLight.position.set(100,200,100);
scene.add(dirLight);

const blockSize = 25;
const texture = new THREE.TextureLoader().load("images/dirt.png");
texture.magFilter = THREE.NearestFilter;
texture.minFilter = THREE.NearestMipMapNearestFilter;

function createBlock(x,y,z){
    const geometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
    const material = new THREE.MeshLambertMaterial({map: texture});
    const cube = new THREE.Mesh(geometry, material);
    cube.position.set(x, y + blockSize/2, z);
    scene.add(cube);
}

for(let i=-5;i<=5;i++){
    for(let j=-5;j<=5;j++){
        createBlock(i*blockSize, 0, j*blockSize);
    }
}

const player = {x:0, y:0, z:0};
let yaw = 0, pitch = 0;
const maxPitch = 89 * Math.PI/180;

const move = {forward:false, backward:false, left:false, right:false};
document.addEventListener('keydown',(e)=>{
    switch(e.code){
        case 'KeyW': move.forward=true; break;
        case 'KeyS': move.backward=true; break;
        case 'KeyA': move.left=true; break;
        case 'KeyD': move.right=true; break;
    }
});
document.addEventListener('keyup',(e)=>{
    switch(e.code){
        case 'KeyW': move.forward=false; break;
        case 'KeyS': move.backward=false; break;
        case 'KeyA': move.left=false; break;
        case 'KeyD': move.right=false; break;
    }
});

// 視線操作（PC）
document.addEventListener('mousemove',(e)=>{
    const sensitivity = 0.002;
    yaw -= e.movementX * sensitivity;
    pitch -= e.movementY * sensitivity;
    pitch = Math.max(-maxPitch, Math.min(maxPitch, pitch));
});

// 視線操作（Mobile）
let lastTouchX=0, lastTouchY=0;
document.addEventListener('touchstart',(e)=>{
    if(e.touches.length===1){
        lastTouchX = e.touches[0].pageX;
        lastTouchY = e.touches[0].pageY;
    }
});
document.addEventListener('touchmove',(e)=>{
    if(e.touches.length===1){
        const dx = e.touches[0].pageX - lastTouchX;
        const dy = e.touches[0].pageY - lastTouchY;
        lastTouchX = e.touches[0].pageX;
        lastTouchY = e.touches[0].pageY;

        const sensitivity = 0.002;
        yaw -= dx*sensitivity;
        pitch -= dy*sensitivity;
        pitch = Math.max(-maxPitch, Math.min(maxPitch, pitch));
    }
});

const raycaster = new THREE.Raycaster();

function animate() {
    requestAnimationFrame(animate);

    // 移動
    const speed = 2;
    const dir = new THREE.Vector3();
    if(move.forward) dir.z -= 1;
    if(move.backward) dir.z += 1;
    if(move.left) dir.x -= 1;
    if(move.right) dir.x += 1;
    dir.normalize();

    // カメラ向きベクトル
    const forward = new THREE.Vector3(Math.sin(yaw),0,Math.cos(yaw));
    const right = new THREE.Vector3(Math.sin(yaw+Math.PI/2),0,Math.cos(yaw+Math.PI/2));

    player.x += forward.x*dir.z*speed + right.x*dir.x*speed;
    player.z += forward.z*dir.z + right.z*dir.x*speed;

    // カメラ位置
    let camPos = new THREE.Vector3(player.x, player.y + blockSize, player.z);

    // Raycasterでめり込み回避
    const camDir = new THREE.Vector3(0,0,1).applyEuler(new THREE.Euler(pitch, yaw, 0));
    raycaster.set(new THREE.Vector3(player.x, player.y, player.z), camDir);
    raycaster.far = blockSize * 2; // 適当な距離
    const intersects = raycaster.intersectObjects(scene.children, true);
    if(intersects.length > 0) {
        const hit = intersects[0].point;
        camPos.copy(hit.add(camDir.clone().multiplyScalar(-0.1)));
    }

    camera.position.copy(camPos);

    // カメラ回転をEulerで直接設定
    camera.rotation.set(pitch, yaw, 0);

    renderer.render(scene, camera);
}

animate();

window.addEventListener('resize',()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
