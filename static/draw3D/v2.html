<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>3D cube</title>
<style>
  body { margin:0; overflow:hidden; }
  canvas { display:block;}
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<script src="https://unpkg.com/three@0.137.4/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.137.4/examples/js/controls/OrbitControls.js"></script>

<script>
  // シーン作成
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb); // 空色

  // カメラ
  const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 1000);
  camera.position.set(0, 150, 300);

  // レンダラー
  const renderer = new THREE.WebGLRenderer({
    canvas: document.querySelector('#canvas')
  });
  renderer.setSize(window.innerWidth, window.innerHeight);

  // マウス操作
  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.target.set(0, 0, 0);
  controls.enableZoom = false; // ここで拡大縮小OFF
  controls.update();

  // 光源
  scene.add(new THREE.AmbientLight(0xffffff, 0.6));
  const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
  dirLight.position.set(100, 200, 100);
  scene.add(dirLight);

  // テクスチャ読み込み
  const loader = new THREE.TextureLoader();
  loader.load("images/dirt.png", (texture) => {
    texture.magFilter = THREE.NearestFilter;
    texture.minFilter = THREE.NearestMipMapNearestFilter;

    // ブロック作成関数（1個ずつメッシュ生成）
    function createBlock(x, y, z){
      const geometry = new THREE.BoxGeometry(50,50,50);

      // 展開図が4x3タイルの場合のUV設定
      const tileUvWidth  = 1/4;
      const tileUvHeight = 1/3;

      function applyFaceUV(faceIndex, tx, ty){
        const uvs = geometry.attributes.uv.array;
        const offset = faceIndex * 4 * 2;
        const u0 = tx * tileUvWidth;
        const v0 = 1 - (ty+1) * tileUvHeight;
        const u1 = (tx+1) * tileUvWidth;
        const v1 = 1 - ty * tileUvHeight;

        uvs[offset]   = u0; uvs[offset+1] = v1;
        uvs[offset+2] = u1; uvs[offset+3] = v1;
        uvs[offset+4] = u0; uvs[offset+5] = v0;
        uvs[offset+6] = u1; uvs[offset+7] = v0;
      }

      // 各面に切り取り座標を割り当て
      applyFaceUV(0, 2, 1); // right
      applyFaceUV(1, 0, 1); // left
      applyFaceUV(2, 1, 0); // top
      applyFaceUV(3, 1, 2); // bottom
      applyFaceUV(4, 1, 1); // front
      applyFaceUV(5, 3, 1); // back
      geometry.attributes.uv.needsUpdate = true;

      const material = new THREE.MeshLambertMaterial({ map: texture });
      const cube = new THREE.Mesh(geometry, material);
      cube.position.set(x, y + 25, z); // y=0を地面にするため +25
      scene.add(cube);
    }

    // 地面作成（11x11）
    for(let i=-5;i<=5;i++){
      for(let j=-5;j<=5;j++){
        createBlock(i*50, 0, j*50);
      }
    }
  });

  // アニメーションループ
  function animate(){
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
  }
  animate();

  // リサイズ対応
  window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>
</body>
</html>
