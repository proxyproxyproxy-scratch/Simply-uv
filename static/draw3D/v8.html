<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Three.js FPS with joystick & jump</title>
<style>
  body { margin:0; overflow:hidden; }
  canvas { display:block; }
  #joystick {
    position: fixed;
    bottom: 20px;
    left: 20px;
    width: 200px;
    height: 200px;
    border-radius: 50%;
    background-color: #ffffffcc;
    touch-action: none;
  }
  #jumpBtn {
    position: fixed;
    bottom: 50px;
    right: 20px;
    width: 80px;
    height: 80px;
    border-radius: 50%;
    background-color: #ffffffcc;
    font-size: 20px;
    text-align: center;
    line-height: 80px;
    user-select: none;
    touch-action: none;
  }
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="joystick"></div>
<div id="jumpBtn">Jump</div>

<script src="https://unpkg.com/three@0.137.4/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.137.4/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.9.0/nipplejs.min.js"></script>

<script>
// =======================
// 基本設定
// =======================
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 5, 500);
camera.position.set(0,50,25);

const renderer = new THREE.WebGLRenderer({canvas:document.getElementById('canvas')});
renderer.setSize(window.innerWidth, window.innerHeight);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableZoom = false;
controls.enablePan = false;
controls.target.set(0,50,0);
controls.update();

scene.add(new THREE.AmbientLight(0xffffff,0.6));
const dirLight = new THREE.DirectionalLight(0xffffff,0.6);
dirLight.position.set(100,200,100);
scene.add(dirLight);

// =======================
// ブロック設定
// =======================
const blockSize = 25;
const texture = new THREE.TextureLoader().load("images/soil.png");
texture.magFilter = THREE.NearestFilter;
texture.minFilter = THREE.NearestMipMapNearestFilter;

// ブロックタイプ（後から追加可）
const CubeTypes = {
  soil: { textureX:1, textureY:1 },
  grass:{ textureX:2, textureY:0 },
};

// ブロック保存用配列
const cubes = [];

function createBlock(x,y,z,type='soil'){
  const geometry = new THREE.BoxGeometry(blockSize,blockSize,blockSize);
  const tileUvWidth = 1/4, tileUvHeight=1/3;

  const cubeType = CubeTypes[type] || CubeTypes.soil;

  function applyFaceUV(faceIndex, tx, ty){
    const uvs = geometry.attributes.uv.array;
    const offset = faceIndex*4*2;
    const u0=tx*tileUvWidth,v0=1-(ty+1)*tileUvHeight;
    const u1=(tx+1)*tileUvWidth,v1=1-ty*tileUvHeight;
    uvs[offset] = u0; uvs[offset+1]=v1;
    uvs[offset+2] = u1; uvs[offset+3]=v1;
    uvs[offset+4] = u0; uvs[offset+5]=v0;
    uvs[offset+6] = u1; uvs[offset+7] = v0;
  }

  // 各面のUV（とりあえず soil 用）
  applyFaceUV(0, cubeType.textureX, cubeType.textureY);
  applyFaceUV(1, 0, 1);
  applyFaceUV(2, 1, 0);
  applyFaceUV(3, 1, 2);
  applyFaceUV(4, 1, 1);
  applyFaceUV(5, 3, 1);

  geometry.attributes.uv.needsUpdate = true;
  const material = new THREE.MeshLambertMaterial({map:texture});
  const cube = new THREE.Mesh(geometry,material);
  cube.position.set(x,y+blockSize/2,z);

  scene.add(cube);

  // 配列に保存
  cubes.push({ mesh:cube, x, y, z, type });
}

// 地面生成
for(let i=-5;i<=5;i++){
  for(let j=-5;j<=5;j++){
    createBlock(i*blockSize,0,j*blockSize,'soil');
  }
}

// =======================
// ジョイスティック操作
// =======================
const joystick = nipplejs.create({
  zone: document.getElementById('joystick'),
  mode:'static',
  position:{left:'50%',top:'50%'},
  size:200,
  color:'blue',
  multitouch:true
});

let moveForward=0, moveRight=0;
joystick.on('move',(evt,data)=>{
  const rad = data.angle.radian;
  moveForward = Math.sin(rad) * data.distance * 0.02;
  moveRight   = Math.cos(rad) * data.distance * 0.02;
});
joystick.on('end',()=>{ moveForward=0; moveRight=0; });

// =======================
// ジャンプ
// =======================
let velocityY=0;
const gravity=-0.8, jumpSpeed=3.1;
let onGround=true;

const jumpBtn = document.getElementById('jumpBtn');
const jumpHandler = () => { if(onGround){ velocityY=jumpSpeed; onGround=false; } };
jumpBtn.addEventListener('touchstart', jumpHandler);
jumpBtn.addEventListener('pointerdown', jumpHandler);

window.addEventListener('keydown',(e)=>{
  if(e.code==='Space' && onGround){ velocityY=jumpSpeed; onGround=false; }
});
  
function getGroundHeight(x, z, maxYLimit){
  let maxY = -Infinity;
  for (const c of cubes) {
    const half = blockSize/2;
    if (x >= c.x - half && x <= c.x + half &&
        z >= c.z - half && z <= c.z + half) {
      const topY = c.y + blockSize;
      // maxYLimit 以下のブロックだけ考慮
      if (topY <= maxYLimit && topY > maxY) maxY = topY;
    }
  }
  return (maxY === -Infinity) ? 0 : maxY;
}

// =======================
// アニメーション
// =======================
const forward = new THREE.Vector3();
const right = new THREE.Vector3();
const groundHeight = 50;
let count=1;
function animate(){
  requestAnimationFrame(animate);
  count +=1;
  if(count%50=1){alert(getGroundHeight(controls.target.x,controls.target.z,controls.target.y));}
  camera.getWorldDirection(forward);
  forward.y = 0; forward.normalize();
  right.crossVectors(forward,new THREE.Vector3(0,1,0)).normalize();

  // 前後左右移動
  camera.position.addScaledVector(forward, moveForward);
  controls.target.addScaledVector(forward, moveForward);
  camera.position.addScaledVector(right, moveRight);
  controls.target.addScaledVector(right, moveRight);

  // ジャンプ / 重力
  const offsetY = camera.position.y - controls.target.y;
  velocityY += gravity * 0.1;
  camera.position.y += velocityY;
  controls.target.y += velocityY;

  // 着地判定
  if(controls.target.y <= groundHeight){
    controls.target.y = groundHeight;
    camera.position.y = groundHeight + offsetY;
    velocityY = 0;
    onGround = true;
  }

  controls.update();
  renderer.render(scene,camera);
}
animate();

// =======================
// リサイズ対応
// =======================
window.addEventListener('resize',()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});

// =======================
// CubeTypes追加例
// =======================
// CubeTypes.stone = { textureX:3, textureY:2 };
// createBlock(30,0,0,'stone');

</script>
</body>
</html>
