<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>3Dキューブ</title>
  <style>
    body { margin:0; overflow:hidden; }
    canvas { display:block; }
  </style>
</head>
<body>
<canvas id="canvas"></canvas>
<script src="https://unpkg.com/three@0.137.4/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.137.4/examples/js/controls/OrbitControls.js"></script>
<script>
// シーン
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);

// カメラ
const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 1000);
camera.position.set(150, 150, 250);

// レンダラー
const renderer = new THREE.WebGLRenderer({canvas: document.querySelector('#canvas')});
renderer.setSize(window.innerWidth, window.innerHeight);

// コントロール
const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.target.set(0, 50, 0);
controls.update();

// ライト
scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
dirLight.position.set(100, 200, 100);
scene.add(dirLight);

// BoxGeometry
const geometry = new THREE.BoxGeometry(50, 50, 50);

// 展開図が4x3のタイル状
const tileUvWidth  = 1/4;
const tileUvHeight = 1/3;

// UV設定関数
function applyFaceUV(faceIndex, x, y) {
  const uvs = geometry.attributes.uv.array;
  const offset = faceIndex * 4 * 2;
  const u0 = x * tileUvWidth;
  const v0 = 1 - (y+1) * tileUvHeight;
  const u1 = (x+1) * tileUvWidth;
  const v1 = 1 - y * tileUvHeight;

  uvs[offset]   = u0; uvs[offset+1] = v1;
  uvs[offset+2] = u1; uvs[offset+3] = v1;
  uvs[offset+4] = u0; uvs[offset+5] = v0;
  uvs[offset+6] = u1; uvs[offset+7] = v0;
}

// 各面に展開図の座標を指定
applyFaceUV(0, 2, 1); // right
applyFaceUV(1, 0, 1); // left
applyFaceUV(2, 1, 0); // top
applyFaceUV(3, 1, 2); // bottom
applyFaceUV(4, 1, 1); // front
applyFaceUV(5, 3, 1); // back
geometry.attributes.uv.needsUpdate = true;

// --- ここからテクスチャをロードしてキューブ作成 ---
const loader = new THREE.TextureLoader();
loader.load("./images/soil.png", (texture) => {
  texture.magFilter = THREE.NearestFilter;
  texture.minFilter = THREE.NearestMipMapNearestFilter;

  const material = new THREE.MeshLambertMaterial({ map: texture });
  const cube = new THREE.Mesh(geometry, material);
  scene.add(cube);
});

// アニメーション
function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();

// リサイズ対応
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
