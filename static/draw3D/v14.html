<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Three.js FPS with joystick & jump</title>
<style>
body { margin:0; overflow:hidden; }
canvas { display:block; }
#joystick {
  position: fixed; bottom: 20px; left: 20px;
  width: 200px; height: 200px; border-radius: 50%;
  background-color: #ffffffcc; touch-action: none;
}
#jumpBtn {
  position: fixed; bottom: 50px; right: 20px;
  width: 80px; height: 80px; border-radius: 50%;
  background-color: #ffffffcc; font-size: 20px;
  text-align: center; line-height: 80px;
  user-select: none; touch-action: none;
}
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="joystick"></div>
<div id="jumpBtn">Jump</div>

<script src="https://unpkg.com/three@0.137.4/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.137.4/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.9.0/nipplejs.min.js"></script>

<script>
// =======================
// 基本設定
// =======================
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 500);
camera.position.set(0,100,1);

const renderer = new THREE.WebGLRenderer({canvas:document.getElementById('canvas')});
renderer.setSize(window.innerWidth, window.innerHeight);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableZoom = false;
controls.enablePan = false;
controls.target.set(0,100,0);
controls.update();

scene.add(new THREE.AmbientLight(0xffffff,0.6));
const dirLight = new THREE.DirectionalLight(0xffffff,0.6);
dirLight.position.set(100,200,100);
scene.add(dirLight);

// =======================
// ブロック設定
// =======================
const blockSize = 25;
const eyeHeight = blockSize*1.5;

// テクスチャ読み込み
const textureGrass   = new THREE.TextureLoader().load("images/grass.png");
textureGrass.magFilter = THREE.NearestFilter;
textureGrass.minFilter = THREE.NearestMipMapNearestFilter;
textureGrass.generateMipmaps = false;

const textureSoil   = new THREE.TextureLoader().load("images/soil.png");
textureSoil.magFilter = THREE.NearestFilter;
textureSoil.minFilter = THREE.NearestMipMapNearestFilter;
textureSoil.generateMipmaps = false;

const textureGravel = new THREE.TextureLoader().load("images/gravel.png");
textureGravel.magFilter = THREE.NearestFilter;
textureGravel.minFilter = THREE.NearestFilter;
textureGravel.generateMipmaps = false;

// ブロックタイプ（4x3のタイルアトラス想定）
const CubeTypes = { soil:{texture:textureSoil}, grass:{texture:textureGrass}, gravel:{texture:textureGravel} };

// ブロック保存用配列
const cubes = [];

function createBlock(x,y,z,type='grass'){
  const geometry = new THREE.BoxGeometry(blockSize,blockSize,blockSize);
  const cubeType = CubeTypes[type] || CubeTypes.soil;

  const tileUvWidth  = 1/4;
  const tileUvHeight = 1/3;
  function applyFaceUV(faceIndex, tx, ty){
    const uvs = geometry.attributes.uv.array;
    const offset = faceIndex*4*2;
    const u0=tx*tileUvWidth, v0=1-(ty+1)*tileUvHeight;
    const u1=(tx+1)*tileUvWidth, v1=1-ty*tileUvHeight;
    uvs[offset]   = u0; uvs[offset+1] = v1;
    uvs[offset+2] = u1; uvs[offset+3] = v1;
    uvs[offset+4] = u0; uvs[offset+5] = v0;
    uvs[offset+6] = u1; uvs[offset+7] = v0;
  }

  applyFaceUV(0,1,1); applyFaceUV(1,0,1);
  applyFaceUV(2,1,0); applyFaceUV(3,1,2);
  applyFaceUV(4,1,1); applyFaceUV(5,3,1);

  geometry.attributes.uv.needsUpdate = true;

  const material = new THREE.MeshLambertMaterial({map:cubeType.texture});
  const cube = new THREE.Mesh(geometry,material);
  cube.position.set(x,y+blockSize/2,z);
  scene.add(cube);
  cubes.push({ mesh:cube, x, y, z, type });
}

// 地面生成
for(let i=-5;i<=5;i++) for(let j=-5;j<=5;j++) createBlock(i*blockSize,0,j*blockSize,'grass');
// gravel配置
for(let i=-5;i<=5;i++) createBlock(i*blockSize,blockSize,i*blockSize,'gravel');
createBlock(0,2*blockSize,0,'gravel');

// =======================
// ジョイスティック操作
// =======================
const joystick = nipplejs.create({
  zone: document.getElementById('joystick'),
  mode:'static',
  position:{left:'50%',top:'50%'},
  size:200,
  color:'blue',
  multitouch:true
});

let moveForward=0, moveRight=0;
joystick.on('move',(evt,data)=>{
  const rad = data.angle.radian;
  moveForward = Math.sin(rad)*data.distance*0.02;
  moveRight   = Math.cos(rad)*data.distance*0.02;
});
joystick.on('end',()=>{ moveForward=0; moveRight=0; });

// =======================
// ジャンプ
// =======================
let velocityY=0;
const gravity=-0.8, jumpSpeed=3.1;
let onGround=true;

const jumpBtn = document.getElementById('jumpBtn');
const jumpHandler = ()=>{ if(onGround){ velocityY=jumpSpeed; onGround=false; } };
jumpBtn.addEventListener('touchstart', jumpHandler);
jumpBtn.addEventListener('pointerdown', jumpHandler);

window.addEventListener('keydown',(e)=>{
  if(e.code==='Space' && onGround){ velocityY=jumpSpeed; onGround=false; }
});

// =======================
// 衝突判定・横登り処理
// =======================
function getBlockAt(x,z,maxY){
  const half = blockSize/2;
  let candidates = cubes.filter(c=>{
    return x >= c.x-half && x <= c.x+half &&
           z >= c.z-half && z <= c.z+half &&
           c.y <= maxY;
  });
  if(candidates.length===0) return null;
  return candidates.reduce((a,b)=> (a.y>b.y)?a:b);
}

// =======================
// アニメーション
// =======================
const forward = new THREE.Vector3();
const right   = new THREE.Vector3();

let isClimbing = false;
let climbRemaining = 0;
const climbSpeed = 5; // 1秒で5ブロック登るペース（調整可）

function animate(){
  requestAnimationFrame(animate);

  camera.getWorldDirection(forward);
  forward.y=0; forward.normalize();
  right.crossVectors(forward,new THREE.Vector3(0,1,0)).normalize();

  let dx = moveForward*forward.x + moveRight*right.x;
  let dz = moveForward*forward.z + moveRight*right.z;
  let targetX = controls.target.x + dx;
  let targetZ = controls.target.z + dz;

  // ==== 登り判定 ====
  if(!isClimbing){
    const block = getBlockAt(targetX,targetZ,controls.target.y);
    if(block){
      const diffY = block.y + blockSize - (controls.target.y - eyeHeight);
      if(diffY <= blockSize && diffY > 0){
        isClimbing = true;
        climbRemaining = Math.min(diffY, 1.5); // 登る残り距離を記憶
      } else if(diffY <= 0){
        // 平地または下り
        controls.target.x += dx;
        controls.target.z += dz;
        camera.position.x += dx;
        camera.position.z += dz;
      }
    } else {
      controls.target.x += dx;
      controls.target.z += dz;
      camera.position.x += dx;
      camera.position.z += dz;
    }
  }

  // ==== 登坂中 ====
  if(isClimbing){
    const climbStep = Math.min(climbSpeed * 0.016, climbRemaining); // 60fps想定で1/60秒ごと
    controls.target.y += climbStep;
    camera.position.y += climbStep;
    climbRemaining -= climbStep;

    controls.target.x += dx;
    controls.target.z += dz;
    camera.position.x += dx;
    camera.position.z += dz;

    if(climbRemaining <= 0){
      isClimbing = false;
    }
  }

  // ==== 重力・ジャンプ ====
  const offsetY = camera.position.y - controls.target.y;
  velocityY += gravity * 0.1;
  camera.position.y += velocityY;
  controls.target.y += velocityY;

  const groundBlock = getBlockAt(controls.target.x,controls.target.z,controls.target.y);
  const groundY = groundBlock ? groundBlock.y + blockSize : 0;
  if(controls.target.y <= groundY + eyeHeight){
    controls.target.y = groundY + eyeHeight;
    camera.position.y = controls.target.y + offsetY;
    velocityY = 0;
    onGround = true;
  }

  controls.update();
  renderer.render(scene,camera);
}

animate();

// =======================
// リサイズ
// =======================
window.addEventListener('resize',()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});

</script>
</body>
</html>
